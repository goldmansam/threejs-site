<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Samuel Goldman — Particle Portfolio</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800;900&display=swap" rel="stylesheet">

<style>
  :root{ --rail-w:210px; --neon:#00ff88; }
  html,body{height:100%;margin:0;background:#010204;overflow:hidden}
  canvas{display:block}

  /* Left rail */
  .rail{
    position:fixed; inset:0 auto 0 0; width:var(--rail-w); z-index:30;
    padding:18px 14px; display:grid; gap:10px; align-content:start;
    background:linear-gradient(180deg,rgba(3,4,6,.92),rgba(3,4,6,.62));
    border-right:1px solid rgba(255,255,255,.07);
    backdrop-filter: blur(8px);
    color:#dff7ee; font:14px/1.3 'Orbitron', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    letter-spacing:.03em
  }
  .brand{font-weight:900;letter-spacing:.08em;opacity:.95;text-transform:uppercase}
  .vnav{display:grid;gap:8px;margin-top:6px}
  .vnav button{
    appearance:none; border:1px solid rgba(255,255,255,.14);
    background:rgba(8,10,12,.68); color:#dff7ee; padding:10px 12px; border-radius:999px;
    text-align:left; cursor:pointer; transition:all .16s ease;
    font-family:'Orbitron',sans-serif; letter-spacing:.05em
  }
  .vnav button:hover{border-color:rgba(255,255,255,.28); background:rgba(12,14,18,.78)}
  .vnav button.active{color:#9ff; border-color:rgba(160,240,255,.55)}

  /* HUD: arrows + audio */
  .hud{ position:fixed; right:18px; bottom:18px; z-index:30; display:flex; gap:10px; align-items:center }
  .arrow,.audioBtn{
    height:44px; min-width:44px; padding:0 12px; border-radius:999px; border:1px solid rgba(255,255,255,.18);
    background:radial-gradient(120% 120% at 30% 30%, rgba(255,255,255,.14), rgba(10,12,14,.7));
    box-shadow:0 0 14px rgba(0,255,160,.16), inset 0 0 14px rgba(0,255,160,.12);
    color:#e8eef8; display:grid; place-items:center; cursor:pointer; user-select:none;
    font-family:'Orbitron',sans-serif; letter-spacing:.06em; font-size:12px
  }
  .arrow span{font-size:16px; transform:translateY(-1px)}
  .arrow:hover,.audioBtn:hover{box-shadow:0 0 20px rgba(0,255,160,.26), inset 0 0 20px rgba(0,255,160,.18)}
  .audioBtn{padding:0 12px}

  /* Neon overlay */
  .overlay{ position:fixed; inset:0; z-index:40; display:none; place-items:center; }
  .overlay.show{display:grid}
  .overlay::before,.overlay::after{ content:""; position:absolute; inset:0; pointer-events:none; mix-blend-mode:screen; }
  .overlay::before{
    background:
      radial-gradient(800px 800px at 20% 30%, rgba(0,255,150,.06), rgba(0,0,0,0) 60%),
      radial-gradient(600px 600px at 70% 60%, rgba(0,255,190,.05), rgba(0,0,0,0) 60%),
      repeating-linear-gradient( to bottom, rgba(0,255,160,.05) 0 2px, rgba(0,0,0,0) 2px 11px);
    animation: flow1 16s linear infinite;
  }
  .overlay::after{
    background:
      conic-gradient(from 0deg, rgba(0,255,160,.05), rgba(0,255,120,.035), rgba(0,255,160,.05)),
      radial-gradient(1000px 1000px at 80% 20%, rgba(0,255,120,.06), rgba(0,0,0,0) 65%);
    animation: flow2 26s linear infinite; opacity:.5;
  }
  @keyframes flow1{ from{background-position:0 0,0 0,0 0} to{background-position:0 700px,0 1400px,0 1000px} }
  @keyframes flow2{ from{filter:hue-rotate(0deg)} to{filter:hue-rotate(360deg)} }
  .panel{
    position:relative; z-index:41; width:min(900px, calc(100vw - var(--rail-w) - 80px));
    border:1px solid rgba(0,255,160,.28);
    background: linear-gradient(180deg, rgba(0,14,9,.86), rgba(0,6,4,.86));
    box-shadow: 0 0 24px rgba(0,255,160,.14), inset 0 0 18px rgba(0,255,160,.1);
    border-radius:16px; padding:22px; color:#ccffe8; font:14px/1.6 'Orbitron',sans-serif; letter-spacing:.03em
  }
  .panel h2{ margin:0 0 10px 0; font-weight:900; letter-spacing:.08em; text-transform:uppercase }
  .close{
    position:absolute; top:10px; right:10px; cursor:pointer; border:1px solid rgba(0,255,160,.32);
    border-radius:999px; padding:6px 10px; color:#00ffb3; background:rgba(0,22,16,.45);
    box-shadow:0 0 12px rgba(0,255,160,.14), inset 0 0 10px rgba(0,255,160,.1);
    font-family:'Orbitron',sans-serif; letter-spacing:.06em
  }

  @media(max-width:920px){ :root{ --rail-w: 170px; } .rail{ width:var(--rail-w);} }
</style>
</head>
<body>
  <aside class="rail">
    <div class="brand">Samuel Goldman</div>
    <div class="vnav">
      <button data-key="start"   class="active">Start</button>
      <button data-key="work">Work</button>
      <button data-key="about">About</button>
      <button data-key="contact">Contact</button>
    </div>
  </aside>

  <div class="hud">
    <div class="arrow" id="prev"><span>◀</span></div>
    <div class="arrow" id="next"><span>▶</span></div>
    <button id="audioBtn" class="audioBtn">AUDIO: OFF</button>
  </div>

  <div id="overlay" class="overlay">
    <div class="panel">
      <button class="close" id="close">Close</button>
      <h2 id="ov-title">Section</h2>
      <div id="ov-body"><p>Neon overlay. Replace with real content.</p></div>
    </div>
  </div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ================= Config ================= */
const CONFIG = {
  AMBIENT_COUNT: 36000,     // more loose cloud
  SWARM_COUNT:   22000,     // close ring (small)
  SHAPE_COUNT:   22000,     // dense titles
  BOX: 180, BASE_SPEED: 0.03, DAMPING: 0.985,

  CAMERA_FOV: 60, ORBIT_RADIUS: 175, ORBIT_DAMP: 0.12,
  ORBIT_SENS: { theta: 0.008, phi: 0.006 }, PHI_MIN: 0.25, PHI_MAX: Math.PI - 0.25,

  SECTIONS: ["Samuel Goldman","Work","About","Contact"],

  CANVAS_W: 2600, STEP: 3, THICKNESS: 5, OUTLINE_ONLY: false,
  ATTRACT: 0.022, MORPH_RATE: 0.03,

  DOT_SIZE_TITLE: 0.55, DOT_SIZE_SWARM: 0.36, DOT_SIZE_AMB: 0.32, DOT_OPACITY: 0.98,

  FIELD_RADIUS: 18, FIELD_FORCE: 0.28
};

const SECT = { START:0, WORK:1, ABOUT:2, CONTACT:3 };

/* ================= Scene ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x010203, 0.01);

const camera = new THREE.PerspectiveCamera(CONFIG.CAMERA_FOV, innerWidth/innerHeight, 0.1, 9000);
const pivot = new THREE.Object3D(); scene.add(pivot);
const camHolder = new THREE.Object3D(); camHolder.position.set(0,0,CONFIG.ORBIT_RADIUS);
pivot.add(camHolder); camHolder.add(camera);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setClearColor(0x010204, 1);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x0b120f, 0.9));

/* Dark, subtle green nebula */
const nebulaUniforms = { uTime:{value:0}, uIntensity:{value:0.4}, uHueShift:{value:0.0} };
const nebulaMat = new THREE.ShaderMaterial({
  side: THREE.BackSide, uniforms: nebulaUniforms,
  vertexShader: `varying vec3 vPos; void main(){ vPos=normalize(position); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
  fragmentShader: `
    precision highp float; varying vec3 vPos; uniform float uTime; uniform float uIntensity; uniform float uHueShift;
    float n(vec3 p){ return sin(p.x)*sin(p.y)*sin(p.z); }
    float fbm(vec3 p){ float f=0.0,a=0.5; for(int i=0;i<6;i++){ f+=a*n(p); p*=2.03; p+=vec3(.1,.27,-.19); a*=.55; } return f; }
    vec3 pal(float t){
      vec3 a=vec3(.03,.10,.06), b=vec3(.04,.12,.07), c=vec3(.02,.08,.05);
      float k1=.5+.5*sin(6.2831*(t+uHueShift)), k2=.5+.5*sin(6.2831*(t*1.3+.23+uHueShift));
      return mix(mix(a,b,k1), c, k2);
    }
    void main(){
      vec3 p = normalize(vPos)*2.0 + vec3(0.,0.,uTime*0.03);
      float d = fbm(p*2.0 + uTime*0.05);
      float m = smoothstep(-.6,.9,d);
      vec3 col = mix(vec3(0.,0.,0.), pal(m), uIntensity*(.22+.5*m));
      gl_FragColor = vec4(col, 1.0);
    }`
});
const nebula = new THREE.Mesh(new THREE.SphereGeometry(3600,64,64), nebulaMat);
pivot.add(nebula);

/* Dot texture: white core + faint green halo */
function makeDotTexture(size=96){
  const c=document.createElement("canvas"); c.width=c.height=size; const g=c.getContext("2d");
  const r=size/2, grad=g.createRadialGradient(r,r,0,r,r,r);
  grad.addColorStop(0,"rgba(255,255,255,1)");
  grad.addColorStop(.5,"rgba(255,255,255,.9)");
  grad.addColorStop(.7,"rgba(120,255,190,.30)");
  grad.addColorStop(1,"rgba(120,255,190,0)");
  g.fillStyle=grad; g.beginPath(); g.arc(r,r,r,0,Math.PI*2); g.fill();
  const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=false; 
  return tex;
}
const dotTex = makeDotTexture();

/* Stage that always faces camera */
const stage = new THREE.Object3D(); pivot.add(stage);

/* Ambient cloud (mouse-reactive; small dots) */
const rnd=(a,b)=>a+Math.random()*(b-a);
const ambCount=CONFIG.AMBIENT_COUNT;
const ambPos=new Float32Array(ambCount*3), ambVel=new Float32Array(ambCount*3);
for(let i=0;i<ambCount;i++){
  const j=i*3;
  ambPos[j+0]=rnd(-CONFIG.BOX,CONFIG.BOX);
  ambPos[j+1]=rnd(-CONFIG.BOX,CONFIG.BOX);
  ambPos[j+2]=rnd(-520,520);
  ambVel[j+0]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  ambVel[j+1]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  ambVel[j+2]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
}
const ambGeom=new THREE.BufferGeometry();
ambGeom.setAttribute("position", new THREE.BufferAttribute(ambPos,3));
const ambMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE_AMB,map:dotTex,alphaTest:0.02,transparent:true,opacity:0.7,depthWrite:false,blending:THREE.AdditiveBlending
});
const ambientPoints=new THREE.Points(ambGeom,ambMat); scene.add(ambientPoints);

/* Swarm ring (smaller dots) */
const swarmCount=CONFIG.SWARM_COUNT;
const swarmPos=new Float32Array(swarmCount*3), swarmTheta=new Float32Array(swarmCount);
const swarmRad=new Float32Array(swarmCount), swarmSpeed=new Float32Array(swarmCount), swarmYOff=new Float32Array(swarmCount);
for(let i=0;i<swarmCount;i++){
  const j=i*3;
  const r = rnd(22, 78), th = rnd(0, Math.PI*2), sp = rnd(0.05, 0.2), yoff = rnd(-16, 16);
  swarmRad[i]=r; swarmTheta[i]=th; swarmSpeed[i]=sp; swarmYOff[i]=yoff;
  swarmPos[j+0]=Math.cos(th)*r; swarmPos[j+1]=yoff; swarmPos[j+2]=Math.sin(th)*r;
}
const swarmGeom=new THREE.BufferGeometry();
swarmGeom.setAttribute("position", new THREE.BufferAttribute(swarmPos,3));
const swarmMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE_SWARM,map:dotTex,alphaTest:0.02,transparent:true,opacity:0.82,depthWrite:false,blending:THREE.AdditiveBlending
});
const swarmPoints=new THREE.Points(swarmGeom,swarmMat); stage.add(swarmPoints);

/* Title particles (dense) */
const shapeCount=CONFIG.SHAPE_COUNT;
const pos=new Float32Array(shapeCount*3), vel=new Float32Array(shapeCount*3);
for(let i=0;i<shapeCount;i++){
  const j=i*3;
  pos[j+0]=rnd(-CONFIG.BOX*0.5,CONFIG.BOX*0.5);
  pos[j+1]=rnd(-CONFIG.BOX*0.5,CONFIG.BOX*0.5);
  pos[j+2]=rnd(-40,40);
  vel[j+0]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  vel[j+1]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  vel[j+2]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
}
const shapeGeom=new THREE.BufferGeometry();
shapeGeom.setAttribute("position", new THREE.BufferAttribute(pos,3));
const shapeMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE_TITLE,map:dotTex,alphaTest:0.02,transparent:true,opacity:CONFIG.DOT_OPACITY,depthWrite:false,blending:THREE.AdditiveBlending
});
const shapePoints=new THREE.Points(shapeGeom,shapeMat); stage.add(shapePoints);
shapeGeom.computeBoundingSphere();

const targets=new Float32Array(shapeCount*3);
const morphState={progress:1};

/* Fit helpers (no clipping) */
function frustumWorldWidth(){ const f=THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV); return 2*CONFIG.ORBIT_RADIUS*Math.tan(f/2)*(innerWidth/innerHeight); }
function frustumWorldHeight(){ const f=THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV); return 2*CONFIG.ORBIT_RADIUS*Math.tan(f/2); }
function safeArea(){
  const railPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rail-w')) || 210;
  const worldPerPx = frustumWorldWidth() / innerWidth;
  const railW = railPx * worldPerPx;
  const W = frustumWorldWidth()  - railW * 2.0;
  const H = frustumWorldHeight() * 0.72;
  const centerX = railW * 1.0; // keep extra distance from rail
  return { safeW: Math.max(28,W)*0.92, safeH: Math.max(12,H)*0.92, centerX };
}

/* Text sampling (FILLED) with extents */
function sampleTextNormalized(text){
  const W=CONFIG.CANVAS_W, H=Math.round(W*0.22);
  const cnv=document.createElement("canvas"); cnv.width=W; cnv.height=H;
  const ctx=cnv.getContext("2d"); ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#fff"; ctx.font=`900 ${Math.round(H*0.78)}px "Orbitron", system-ui, Arial`;
  ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(text, W/2, H/2);
  const img=ctx.getImageData(0,0,W,H).data;

  const pts=[]; const step=CONFIG.STEP; const aAt=(x,y)=>img[(y*W+x)*4+3];
  let xmin=1e9,xmax=-1e9,ymin=1e9,ymax=-1e9;
  for(let y=step;y<H-step;y+=step){
    for(let x=step;x<W-step;x+=step){
      if(aAt(x,y)>128){ pts.push([x,y]); if(x<xmin)xmin=x; if(x>xmax)xmax=x; if(y<ymin)ymin=y; if(y>ymax)ymax=y; }
    }
  }
  const cx=(xmin+xmax)/2, cy=(ymin+ymax)/2;
  const wNorm=(xmax-xmin)/W, hNorm=(ymax-ymin)/W;
  const normPts = pts.map(([x,y])=>[(x-cx)/W, (cy-y)/W]);
  return { normPts, wNorm:Math.max(wNorm,1e-4), hNorm:Math.max(hNorm,1e-4) };
}

const NORM = {};
let section = SECT.START; /* ← defined ONCE (bug fixed) */

async function prepareText(){
  try{ await document.fonts.load('900 120px "Orbitron"'); await document.fonts.ready; }catch(e){}
  NORM[SECT.START]   = sampleTextNormalized("Samuel Goldman");
  NORM[SECT.WORK]    = sampleTextNormalized("Work");
  NORM[SECT.ABOUT]   = sampleTextNormalized("About");
  NORM[SECT.CONTACT] = sampleTextNormalized("Contact");
  assignTargetsFor(section);
}

/* Map normalized points → world, fit by width+height, pivot offset for rail */
function assignTargetsFor(idx){
  const data = NORM[idx]; if(!data) return;
  const { normPts, wNorm, hNorm } = data;
  const { safeW, safeH, centerX } = safeArea();
  pivot.position.x = centerX; // clear the rail
  const scale = Math.min(safeW / wNorm, safeH / hNorm) * 0.96; // tiny extra margin
  for(let i=0;i<shapeCount;i++){
    const t = normPts[(Math.random()*normPts.length)|0], j=i*3;
    targets[j+0]=t[0]*scale; targets[j+1]=t[1]*scale; targets[j+2]=THREE.MathUtils.randFloatSpread(CONFIG.THICKNESS*2);
  }
  morphState.progress = 0;
}

/* Swarm follows stage origin */
function updateSwarm(){
  for(let i=0;i<swarmCount;i++){
    const j=i*3;
    swarmTheta[i]+=swarmSpeed[i]*0.01;
    const r=swarmRad[i]*(1.0+0.06*Math.sin(swarmTheta[i]*1.7+i*0.13));
    swarmPos[j+0]=Math.cos(swarmTheta[i])*r;
    swarmPos[j+1]=swarmYOff[i]*(1.0+0.25*Math.sin(swarmTheta[i]*0.7+i*0.09));
    swarmPos[j+2]=Math.sin(swarmTheta[i])*r*0.7;
  }
  swarmGeom.attributes.position.needsUpdate=true;
}

/* Orbit controls (drag 360°) */
let theta=0, phi=Math.PI/2, tTheta=0, tPhi=Math.PI/2, dragging=false, moved=false, lastX=0, lastY=0;
function updateCamera(){
  theta += (tTheta - theta) * CONFIG.ORBIT_DAMP;
  phi   += (tPhi   - phi)   * CONFIG.ORBIT_DAMP;
  const r=CONFIG.ORBIT_RADIUS;
  const x=r*Math.sin(phi)*Math.sin(theta), y=r*Math.cos(phi), z=r*Math.sin(phi)*Math.cos(theta);
  camHolder.position.set(x,y,z); camera.lookAt(pivot.position);
  stage.quaternion.copy(camera.quaternion); // billboard to camera (stable & no clip)
}
addEventListener("pointerdown",(e)=>{ if(e.target.closest('.rail')||e.target.closest('.hud')||e.target.closest('.panel')) return;
  dragging=true; moved=false; lastX=e.clientX; lastY=e.clientY; maybeStartAudio();
});
addEventListener("pointermove",(e)=>{ if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY; if(Math.abs(dx)+Math.abs(dy)>2)moved=true;
  tTheta -= dx*CONFIG.ORBIT_SENS.theta; tPhi -= dy*CONFIG.ORBIT_SENS.phi; tPhi=THREE.MathUtils.clamp(tPhi,CONFIG.PHI_MIN,CONFIG.PHI_MAX);
  lastX=e.clientX; lastY=e.clientY;
});
addEventListener("pointerup",()=>{ if(!dragging) return; dragging=false; if(!moved) openOverlay(section); });
addEventListener("wheel", e=>e.preventDefault(), { passive:false });

/* Mouse field (ambient reacts) */
const raycaster=new THREE.Raycaster(); let mouseNDC=new THREE.Vector2(); let fieldPos=new THREE.Vector3(0,0,0);
addEventListener("pointermove",(e)=>{ const r=renderer.domElement.getBoundingClientRect();
  mouseNDC.x=((e.clientX-r.left)/r.width)*2-1; mouseNDC.y=-((e.clientY-r.top)/r.height)*2+1;
});
function updateMouseField(){
  const plane=new THREE.Plane(), dir=new THREE.Vector3(); camera.getWorldDirection(dir);
  plane.setFromNormalAndCoplanarPoint(dir, pivot.position);
  raycaster.setFromCamera(mouseNDC, camera); raycaster.ray.intersectPlane(plane, fieldPos);
}

/* Nav */
function keyFromIndex(i){ return ["start","work","about","contact"][i]; }
function setSection(to){
  section=to;
  document.querySelectorAll('.vnav button').forEach(b=>b.classList.toggle('active', b.dataset.key===keyFromIndex(section)));
  assignTargetsFor(section);
}
function next(){ setSection(Math.min(SECT.CONTACT, section+1)); }
function prev(){ setSection(Math.max(SECT.START, section-1)); }
document.getElementById("next").addEventListener("click", next);
document.getElementById("prev").addEventListener("click", prev);
document.querySelectorAll('.vnav button').forEach(btn=>{
  btn.addEventListener('click', ()=> setSection({start:0,work:1,about:2,contact:3}[btn.dataset.key]));
});
addEventListener("keydown",(e)=>{ if(e.key==="ArrowRight") next(); if(e.key==="ArrowLeft") prev(); });

/* Overlay */
const overlay=document.getElementById('overlay'); const ovTitle=document.getElementById('ov-title');
document.getElementById('close').addEventListener('click',()=>overlay.classList.remove('show'));
function openOverlay(sec){ const titles=["Samuel Goldman","Work","About","Contact"]; ovTitle.textContent=titles[sec]; overlay.classList.add('show'); }

/* Resize */
addEventListener("resize",()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); assignTargetsFor(section); });

/* Animate */
const ambPosAttr=ambGeom.attributes.position, swarmPosAttr=swarmGeom.attributes.position, shapePosAttr=shapeGeom.attributes.position;
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate); const dt=Math.min(0.05, clock.getDelta()); nebulaUniforms.uTime.value += dt;
  updateCamera(); updateMouseField();
  const r2=CONFIG.FIELD_RADIUS*CONFIG.FIELD_RADIUS;
  for(let i=0;i<ambCount;i++){
    const j=i*3;
    ambVel[j+0]=ambVel[j+0]*CONFIG.DAMPING+(Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambVel[j+1]=ambVel[j+1]*CONFIG.DAMPING+(Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambVel[j+2]=ambVel[j+2]*CONFIG.DAMPING+(Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    const dx=ambPos[j+0]-fieldPos.x, dy=ambPos[j+1]-fieldPos.y, dz=ambPos[j+2]-fieldPos.z, d2=dx*dx+dy*dy+dz*dz;
    if(d2<r2){ const f=(1-d2/r2)*CONFIG.FIELD_FORCE; ambVel[j+0]+=dx*f*dt*28; ambVel[j+1]+=dy*f*dt*28; ambVel[j+2]+=dz*f*dt*28; }
    ambPos[j+0]+=ambVel[j+0]; ambPos[j+1]+=ambVel[j+1]; ambPos[j+2]+=ambVel[j+2];
    const B=CONFIG.BOX, Zmin=-520, Zmax=520;
    if(ambPos[j+0]<-B) ambPos[j+0]+=2*B; else if(ambPos[j+0]>B) ambPos[j+0]-=2*B;
    if(ambPos[j+1]<-B) ambPos[j+1]+=2*B; else if(ambPos[j+1]>B) ambPos[j+1]-=2*B;
    if(ambPos[j+2]<Zmin) ambPos[j+2]=Zmax; else if(ambPos[j+2]>Zmax) ambPos[j+2]=Zmin;
  }
  ambPosAttr.needsUpdate=true;

  for(let i=0;i<swarmCount;i++){
    const j=i*3; swarmTheta[i]+=swarmSpeed[i]*0.01;
    const r=swarmRad[i]*(1.0+0.06*Math.sin(swarmTheta[i]*1.7+i*0.13));
    swarmPos[j+0]=Math.cos(swarmTheta[i])*r; swarmPos[j+1]=swarmYOff[i]*(1.0+0.25*Math.sin(swarmTheta[i]*0.7+i*0.09)); swarmPos[j+2]=Math.sin(swarmTheta[i])*r*0.7;
  }
  swarmPosAttr.needsUpdate=true;

  if(morphState.progress<1) morphState.progress=Math.min(1, morphState.progress+CONFIG.MORPH_RATE);
  for(let i=0;i<shapeCount;i++){
    const j=i*3, m=morphState.progress;
    vel[j+0]=vel[j+0]*CONFIG.DAMPING+(targets[j+0]-pos[j+0])*CONFIG.ATTRACT*m;
    vel[j+1]=vel[j+1]*CONFIG.DAMPING+(targets[j+1]-pos[j+1])*CONFIG.ATTRACT*m;
    vel[j+2]=vel[j+2]*CONFIG.DAMPING+(targets[j+2]-pos[j+2])*CONFIG.ATTRACT*m;
    if(m===1){ vel[j+0]*=0.94; vel[j+1]*=0.94; vel[j+2]*=0.94; }
    pos[j+0]+=vel[j+0]; pos[j+1]+=vel[j+1]; pos[j+2]+=vel[j+2];
  }
  shapePosAttr.needsUpdate=true;

  renderer.render(scene,camera);
}
animate();

/* Build text once fonts are ready */
prepareText();

/* Web Audio */
let audioCtx=null, master=null, noiseSrc=null, bp=null, lfo=null, lfoGain=null, dc=null, tri=null, triGain=null, mix=null, delay=null, fb=null;
let audioOn=false;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  master = audioCtx.createGain(); master.gain.value=0; master.connect(audioCtx.destination);

  noiseSrc = audioCtx.createBufferSource(); const len=audioCtx.sampleRate*2; const buf=audioCtx.createBuffer(1,len,audioCtx.sampleRate);
  const data=buf.getChannelData(0); for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*0.7; noiseSrc.buffer=buf; noiseSrc.loop=true;

  bp = audioCtx.createBiquadFilter(); bp.type="bandpass"; bp.Q.value=7;
  lfo = audioCtx.createOscillator(); lfo.type="sine"; lfo.frequency.value=0.08;
  lfoGain = audioCtx.createGain(); lfoGain.gain.value=500;
  dc = audioCtx.createConstantSource(); dc.offset.value=600; lfo.connect(lfoGain).connect(bp.frequency); dc.connect(bp.frequency);
  lfo.start(); dc.start();

  const noiseGain = audioCtx.createGain(); noiseGain.gain.value=0.16;

  const mod=audioCtx.createOscillator(); mod.frequency.value=0.2; const modGain=audioCtx.createGain(); modGain.gain.value=30;
  tri = audioCtx.createOscillator(); tri.type="triangle"; tri.frequency.value=110; mod.connect(modGain).connect(tri.frequency); mod.start(); tri.start();
  triGain = audioCtx.createGain(); triGain.gain.value=0.05;

  delay = audioCtx.createDelay(5.0); delay.delayTime.value=0.28; fb=audioCtx.createGain(); fb.gain.value=0.32;
  mix = audioCtx.createGain(); mix.gain.value=1.0;

  noiseSrc.connect(bp).connect(noiseGain).connect(mix);
  tri.connect(triGain).connect(mix);
  mix.connect(delay).connect(fb).connect(delay);
  mix.connect(master); delay.connect(master);
  noiseSrc.start();
}
function startAudio(){ if(!audioCtx) initAudio(); audioCtx.resume(); master.gain.cancelScheduledValues(audioCtx.currentTime); master.gain.linearRampToValueAtTime(0, audioCtx.currentTime); master.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime+1.0); audioOn=true; updateAudioBtn(); }
function stopAudio(){ if(!audioCtx) return; master.gain.cancelScheduledValues(audioCtx.currentTime); master.gain.linearRampToValueAtTime(master.gain.value, audioCtx.currentTime); master.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.8); audioOn=false; updateAudioBtn(); }
function updateAudioBtn(){ document.getElementById('audioBtn').textContent = audioOn ? 'AUDIO: ON' : 'AUDIO: OFF'; }
function maybeStartAudio(){ if(!audioOn) startAudio(); }
document.getElementById('audioBtn').addEventListener('click', ()=>{ if(!audioCtx||!audioOn) startAudio(); else stopAudio(); });
</script>
</body>
</html>
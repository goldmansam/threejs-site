<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Samuel Goldman — Particle Portfolio</title>

<!-- Alien/digital font -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800;900&display=swap" rel="stylesheet">

<style>
  :root{
    --rail-w: 210px;
    --neon: #00ff88;
    --neon-soft: rgba(0,255,160,.14);
  }
  html,body{height:100%;margin:0;background:#07080c;overflow:hidden}
  canvas{display:block}

  /* Left rail menu */
  .rail{
    position:fixed; inset:0 auto 0 0; width:var(--rail-w); z-index:30;
    padding:18px 14px; display:grid; gap:10px; align-content:start;
    background:linear-gradient(180deg,rgba(10,12,18,.7),rgba(10,12,18,.35));
    border-right:1px solid rgba(255,255,255,.08);
    backdrop-filter: blur(8px);
    color:#e8eef8; font:14px/1.3 'Orbitron', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    letter-spacing:.03em
  }
  .brand{font-weight:900;letter-spacing:.08em;opacity:.95;text-transform:uppercase}
  .vnav{display:grid;gap:8px;margin-top:6px}
  .vnav button{
    appearance:none; border:1px solid rgba(255,255,255,.14);
    background:rgba(20,22,28,.48); color:#e8eef8; padding:10px 12px; border-radius:999px;
    text-align:left; cursor:pointer; transition:all .16s ease;
    font-family:'Orbitron',sans-serif; letter-spacing:.05em
  }
  .vnav button:hover{border-color:rgba(255,255,255,.28); background:rgba(28,30,36,.58)}
  .vnav button.active{color:#9ff; border-color:rgba(160,240,255,.55)}

  /* Arrow controls (bottom-right) */
  .arrows{
    position:fixed; right:20px; bottom:20px; z-index:30; display:flex; gap:10px
  }
  .arrow{
    width:46px; height:46px; border-radius:999px; border:1px solid rgba(255,255,255,.2);
    background:radial-gradient(120% 120% at 30% 30%, rgba(255,255,255,.25), rgba(30,32,40,.5));
    box-shadow:0 0 18px rgba(160,240,255,.25), inset 0 0 18px rgba(160,240,255,.15);
    color:#e8eef8; display:grid; place-items:center; cursor:pointer; user-select:none;
    font-family:'Orbitron',sans-serif
  }
  .arrow:hover{box-shadow:0 0 22px rgba(160,240,255,.35), inset 0 0 22px rgba(160,240,255,.2)}
  .arrow span{font-size:18px; transform:translateY(-1px)}

  /* Neon green overlay (animated gradient, digital vibe) */
  .overlay{
    position:fixed; inset:0; z-index:40; display:none; place-items:center;
    backdrop-filter: saturate(120%) brightness(1.05);
    pointer-events:auto;
  }
  .overlay.show{display:grid}
  /* Animated multi-layer background */
  .overlay::before, .overlay::after{
    content:""; position:absolute; inset:0; pointer-events:none; mix-blend-mode:screen;
  }
  /* flowing green haze + vertical drift lines */
  .overlay::before{
    background:
      radial-gradient(800px 800px at 20% 30%, rgba(0,255,150,.12), rgba(0,0,0,0) 60%),
      radial-gradient(600px 600px at 70% 60%, rgba(0,255,190,.10), rgba(0,0,0,0) 60%),
      repeating-linear-gradient( to bottom, rgba(0,255,160,.08) 0 2px, rgba(0,0,0,0) 2px 8px);
    animation: flow1 12s linear infinite;
  }
  .overlay::after{
    background:
      conic-gradient(from 0deg, rgba(0,255,160,.10), rgba(0,255,120,.06), rgba(0,255,160,.10)),
      radial-gradient(1000px 1000px at 80% 20%, rgba(0,255,120,.12), rgba(0,0,0,0) 65%);
    animation: flow2 18s linear infinite;
    opacity:.8;
  }
  @keyframes flow1{ from{background-position:0 0,0 0,0 0} to{background-position:0 600px,0 1200px,0 800px} }
  @keyframes flow2{ from{filter:hue-rotate(0deg)} to{filter:hue-rotate(360deg)} }

  .panel{
    position:relative; z-index:41; width:min(900px, calc(100vw - var(--rail-w) - 80px));
    border:1px solid rgba(0,255,160,.35);
    background: linear-gradient(180deg, rgba(0,20,12,.75), rgba(0,8,6,.75));
    box-shadow: 0 0 32px rgba(0,255,160,.15), inset 0 0 24px rgba(0,255,160,.12);
    border-radius:16px; padding:22px; color:#ccffe8; font:14px/1.6 'Orbitron',sans-serif; letter-spacing:.03em
  }
  .panel h2{ margin:0 0 10px 0; font-weight:900; letter-spacing:.08em; text-transform:uppercase }
  .close{
    position:absolute; top:10px; right:10px; cursor:pointer; border:1px solid rgba(0,255,160,.4);
    border-radius:999px; padding:6px 10px; color:#00ffb3; background:rgba(0,30,20,.45);
    box-shadow:0 0 14px rgba(0,255,160,.2), inset 0 0 10px rgba(0,255,160,.1);
    font-family:'Orbitron',sans-serif; letter-spacing:.06em
  }
  @media(max-width:920px){ :root{ --rail-w: 170px; } .rail{ width:var(--rail-w);} }
</style>
</head>
<body>
  <!-- Left menu -->
  <aside class="rail">
    <div class="brand">Samuel Goldman</div>
    <div class="vnav">
      <button data-key="start"   class="active">Start</button>
      <button data-key="work">Work</button>
      <button data-key="about">About</button>
      <button data-key="contact">Contact</button>
    </div>
  </aside>

  <!-- Arrows -->
  <div class="arrows">
    <div class="arrow" id="prev"><span>◀</span></div>
    <div class="arrow" id="next"><span>▶</span></div>
  </div>

  <!-- Neon overlay (click-through content) -->
  <div id="overlay" class="overlay">
    <div class="panel">
      <button class="close" id="close">Close</button>
      <h2 id="ov-title">Section</h2>
      <div id="ov-body">
        <p>Put your content here. I set this up as a modal overlay with a neon-green animated gradient. You can later load real Work/About/Contact content.</p>
      </div>
    </div>
  </div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ================= Config ================= */
const CONFIG = {
  // Particles
  AMBIENT_COUNT: 14000,     // loose 3D cloud (interactive)
  SWARM_COUNT:    8000,     // orbiting ring near title
  SHAPE_COUNT:   16000,     // dense filled titles
  BOX: 150,
  BASE_SPEED: 0.03,
  DAMPING: 0.985,

  // Camera / Orbit
  CAMERA_FOV: 60,
  ORBIT_RADIUS: 155,
  ORBIT_DAMP: 0.12,
  ORBIT_SENS: { theta: 0.008, phi: 0.006 }, // drag sensitivity
  PHI_MIN: 0.2, PHI_MAX: Math.PI - 0.2,     // avoid gimbal at poles

  // Sections (titles)
  SECTIONS: ["Samuel Goldman","Work","About","Contact"],

  // Title sampling
  CANVAS_W: 2200,           // higher res = smoother fill
  STEP: 3,                  // sampling step (lower = denser)
  THICKNESS: 5,             // +/-Z jitter
  OUTLINE_ONLY: false,      // FILLED

  // Morph (single, decisive pull)
  ATTRACT: 0.018,
  MORPH_RATE: 0.022,

  // Dots
  DOT_SIZE: 0.62,
  DOT_OPACITY: 0.96,

  // Mouse field
  FIELD_RADIUS: 14,
  FIELD_FORCE: 0.22
};

const SECT = { START:0, WORK:1, ABOUT:2, CONTACT:3 };

/* ================= Scene ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x06070b, 0.006);

const camera = new THREE.PerspectiveCamera(CONFIG.CAMERA_FOV, innerWidth/innerHeight, 0.1, 5000);

// Pivot group: we orbit the camera around this
const pivot = new THREE.Object3D();
scene.add(pivot);

// Camera child at orbit radius; we rotate pivot to orbit 360°
const camHolder = new THREE.Object3D();
camHolder.position.set(0,0,CONFIG.ORBIT_RADIUS);
pivot.add(camHolder);
camHolder.add(camera);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setClearColor(0x07080c, 1);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x334455, 0.68));

/* ============ Nebula background (never black) ============ */
const nebulaUniforms = { uTime:{value:0}, uIntensity:{value:0.92}, uHueShift:{value:0.0} };
const nebulaMat = new THREE.ShaderMaterial({
  side: THREE.BackSide, uniforms: nebulaUniforms,
  vertexShader: `varying vec3 vPos; void main(){ vPos=normalize(position); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
  fragmentShader: `
    precision highp float; varying vec3 vPos; uniform float uTime; uniform float uIntensity; uniform float uHueShift;
    float n(vec3 p){ return sin(p.x)*sin(p.y)*sin(p.z); }
    float fbm(vec3 p){ float f=0.0,a=0.5; for(int i=0;i<6;i++){ f+=a*n(p); p*=2.03; p+=vec3(.1,.27,-.19); a*=.55; } return f; }
    vec3 pal(float t){
      vec3 a=vec3(.35,.7,.9), b=vec3(.9,.35,.75), c=vec3(.85,.75,.3);
      float k1=.5+.5*sin(6.2831*(t+uHueShift)), k2=.5+.5*sin(6.2831*(t*1.3+.23+uHueShift));
      return mix(mix(a,b,k1), c, k2);
    }
    void main(){
      vec3 p = normalize(vPos)*2.0 + vec3(0.,0.,uTime*0.03);
      float d = fbm(p*2.0 + uTime*0.05);
      float m = smoothstep(-.6,.9,d);
      vec3 col = mix(vec3(.04,.05,.07), pal(m), uIntensity*(.35+.65*m));
      gl_FragColor = vec4(col, 1.0);
    }`
});
const nebula = new THREE.Mesh(new THREE.SphereGeometry(2200,64,64), nebulaMat);
pivot.add(nebula); // attached to pivot so it's always around you

/* ============ Round dot texture ============ */
function makeDotTexture(size=64){
  const c=document.createElement("canvas"); c.width=c.height=size; const g=c.getContext("2d");
  const r=size/2, grad=g.createRadialGradient(r,r,0,r,r,r);
  grad.addColorStop(0,"rgba(255,255,255,1)");
  grad.addColorStop(.7,"rgba(255,255,255,.9)");
  grad.addColorStop(1,"rgba(255,255,255,0)");
  g.fillStyle=grad; g.beginPath(); g.arc(r,r,r,0,Math.PI*2); g.fill();
  const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=false; return tex;
}
const dotTex = makeDotTexture();

/* ============ Palettes ============ */
const PALETTE = [
  [0.30,0.85,0.90],[0.90,0.35,0.85],[0.85,0.75,0.30],
  [0.40,0.95,0.85],[0.95,0.40,0.70],[0.75,0.85,0.35]
];
const rnd=(a,b)=>a+Math.random()*(b-a);

/* ============ Ambient cloud (loose, mouse-interactive) ============ */
const ambCount=CONFIG.AMBIENT_COUNT;
const ambPos=new Float32Array(ambCount*3), ambVel=new Float32Array(ambCount*3), ambCol=new Float32Array(ambCount*3);
for(let i=0;i<ambCount;i++){
  const i3=i*3;
  ambPos[i3+0]=rnd(-CONFIG.BOX,CONFIG.BOX);
  ambPos[i3+1]=rnd(-CONFIG.BOX,CONFIG.BOX);
  ambPos[i3+2]=rnd(-300,300); // spans deep so contact never black
  ambVel[i3+0]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  ambVel[i3+1]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  ambVel[i3+2]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  const c=PALETTE[(Math.random()*PALETTE.length)|0]; ambCol[i3+0]=c[0]; ambCol[i3+1]=c[1]; ambCol[i3+2]=c[2];
}
const ambGeom=new THREE.BufferGeometry();
ambGeom.setAttribute("position", new THREE.BufferAttribute(ambPos,3));
ambGeom.setAttribute("color",    new THREE.BufferAttribute(ambCol,3));
const ambMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE*0.6,map:dotTex,alphaTest:0.02,vertexColors:true,transparent:true,opacity:0.72,depthWrite:false,blending:THREE.AdditiveBlending
});
const ambientPoints=new THREE.Points(ambGeom,ambMat); scene.add(ambientPoints);

/* ============ Swarm ring near title ============ */
const swarmCount=CONFIG.SWARM_COUNT;
const swarmPos=new Float32Array(swarmCount*3), swarmCol=new Float32Array(swarmCount*3);
const swarmTheta=new Float32Array(swarmCount), swarmRad=new Float32Array(swarmCount), swarmSpeed=new Float32Array(swarmCount), swarmYOff=new Float32Array(swarmCount);
for(let i=0;i<swarmCount;i++){
  const i3=i*3;
  const r = rnd(20, 60);                // ring radius
  const th = rnd(0, Math.PI*2);
  const sp = rnd(0.06, 0.18);
  const yoff = rnd(-12, 12);
  swarmRad[i]=r; swarmTheta[i]=th; swarmSpeed[i]=sp; swarmYOff[i]=yoff;
  swarmPos[i3+0]=Math.cos(th)*r; swarmPos[i3+1]=yoff; swarmPos[i3+2]=Math.sin(th)*r;
  const c=PALETTE[(Math.random()*PALETTE.length)|0]; swarmCol[i3+0]=c[0]; swarmCol[i3+1]=c[1]; swarmCol[i3+2]=c[2];
}
const swarmGeom=new THREE.BufferGeometry();
swarmGeom.setAttribute("position", new THREE.BufferAttribute(swarmPos,3));
swarmGeom.setAttribute("color",    new THREE.BufferAttribute(swarmCol,3));
const swarmMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE*0.5,map:dotTex,alphaTest:0.02,vertexColors:true,transparent:true,opacity:0.82,depthWrite:false,blending:THREE.AdditiveBlending
});
const swarmPoints=new THREE.Points(swarmGeom,swarmMat); scene.add(swarmPoints);

/* ============ Title particles (dense, filled) ============ */
const shapeCount=CONFIG.SHAPE_COUNT;
const pos=new Float32Array(shapeCount*3), vel=new Float32Array(shapeCount*3), col=new Float32Array(shapeCount*3);
for(let i=0;i<shapeCount;i++){
  const i3=i*3;
  pos[i3+0]=rnd(-CONFIG.BOX*0.5,CONFIG.BOX*0.5);
  pos[i3+1]=rnd(-CONFIG.BOX*0.5,CONFIG.BOX*0.5);
  pos[i3+2]=rnd(-30,30);
  vel[i3+0]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  vel[i3+1]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  vel[i3+2]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  const c=PALETTE[(Math.random()*PALETTE.length)|0]; col[i3+0]=c[0]; col[i3+1]=c[1]; col[i3+2]=c[2];
}
const shapeGeom=new THREE.BufferGeometry();
shapeGeom.setAttribute("position", new THREE.BufferAttribute(pos,3));
shapeGeom.setAttribute("color",    new THREE.BufferAttribute(col,3));
const shapeMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE,map:dotTex,alphaTest:0.02,vertexColors:true,transparent:true,opacity:CONFIG.DOT_OPACITY,depthWrite:false,blending:THREE.AdditiveBlending
});
const shapePoints=new THREE.Points(shapeGeom,shapeMat); scene.add(shapePoints);
shapeGeom.computeBoundingSphere(); // helpful for raycasting

const targets=new Float32Array(shapeCount*3);
const morphState={progress:1};

/* ====== Text sampling with Orbitron (never cut off) ====== */
function worldUnitsPerPixel(){
  const fovRad = THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV);
  const visibleW = 2 * CONFIG.ORBIT_RADIUS * Math.tan(fovRad/2) * (innerWidth/innerHeight);
  return visibleW / innerWidth;
}
function layoutParams(){
  const railPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rail-w')) || 210;
  const pxToWorld = worldUnitsPerPixel();
  const railUnits = railPx * pxToWorld;
  const fovRad = THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV);
  const visibleW = 2 * CONFIG.ORBIT_RADIUS * Math.tan(fovRad/2) * (innerWidth/innerHeight);
  const safeW = Math.max(30, (visibleW - railUnits) * 0.78); // never tiny; generous margin
  const centerX = railUnits * 0.55; // nudge right of rail
  return { safeW, centerX };
}

function sampleTextNormalized(text){
  const W=CONFIG.CANVAS_W, H=Math.round(W*0.22);
  const cnv=document.createElement("canvas"); cnv.width=W; cnv.height=H;
  const ctx=cnv.getContext("2d");
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#fff";
  ctx.font=`900 ${Math.round(H*0.78)}px "Orbitron", system-ui, Arial`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(text, W/2, H/2);
  const img=ctx.getImageData(0,0,W,H).data;

  const pts=[]; const step=CONFIG.STEP;
  const aAt=(x,y)=>img[(y*W+x)*4+3];
  for(let y=step;y<H-step;y+=step){
    for(let x=step;x<W-step;x+=step){
      if(aAt(x,y)>128){ pts.push([x,y]); } // FILLED (not outline)
    }
  }
  return pts.map(([x,y])=>[(x-W/2)/W, (H/2-y)/W]); // normalized by W
}

const NORM_POINTS = {};
let section = SECT.START;

/* Ensure Orbitron is loaded before sampling */
async function prepareText(){
  try{ await document.fonts.load('900 120px "Orbitron"'); await document.fonts.ready; }catch(e){}
  NORM_POINTS[SECT.START]   = sampleTextNormalized("Samuel Goldman");
  NORM_POINTS[SECT.WORK]    = sampleTextNormalized("Work");
  NORM_POINTS[SECT.ABOUT]   = sampleTextNormalized("About");
  NORM_POINTS[SECT.CONTACT] = sampleTextNormalized("Contact");
  assignTargetsFor(section); // initial
}

/* Map normalized points to world; move pivot to centerX so rail never overlaps */
function assignTargetsFor(sectionIndex){
  const pts = NORM_POINTS[sectionIndex]; if(!pts) return;
  const { safeW, centerX } = layoutParams();

  // move the whole stage so words sit safely to the right of the rail
  pivot.position.x = centerX;

  for(let i=0;i<shapeCount;i++){
    const t = pts[(Math.random()*pts.length)|0];
    const j=i*3;
    targets[j+0] = t[0] * safeW;     // pivot handles the center offset
    targets[j+1] = t[1] * safeW;
    targets[j+2] = THREE.MathUtils.randFloatSpread(CONFIG.THICKNESS*2);
  }
  morphState.progress = 0; // start fresh pull
}

/* Swarm ring follows pivot (title center) */
function updateSwarm(){
  for(let i=0;i<swarmCount;i++){
    const j=i*3;
    swarmTheta[i] += swarmSpeed[i]*0.01;
    const r = swarmRad[i]*(1.0+0.06*Math.sin(swarmTheta[i]*1.7+i*0.13));
    swarmPos[j+0] = Math.cos(swarmTheta[i]) * r;
    swarmPos[j+1] = swarmYOff[i] * (1.0 + 0.25*Math.sin(swarmTheta[i]*0.7 + i*0.09));
    swarmPos[j+2] = Math.sin(swarmTheta[i]) * r * 0.7;
  }
  swarmGeom.attributes.position.needsUpdate = true;
}

/* ================= Orbit controls (drag to rotate fully around) ================= */
let theta = 0, phi = Math.PI/2;      // spherical angles
let tTheta = 0, tPhi = Math.PI/2;    // targets for easing
let dragging = false, moved = false, lastX=0, lastY=0;

function updateCamera(){
  // ease to target
  theta += (tTheta - theta) * CONFIG.ORBIT_DAMP;
  phi   += (tPhi   - tPhi) * 0 + (tPhi - phi) * CONFIG.ORBIT_DAMP; // avoid typo; keep phi easing
  phi   += (tPhi - phi) * CONFIG.ORBIT_DAMP;

  const r = CONFIG.ORBIT_RADIUS;
  const x = r * Math.sin(phi) * Math.sin(theta);
  const y = r * Math.cos(phi);
  const z = r * Math.sin(phi) * Math.cos(theta);

  camHolder.position.set(x,y,z);
  camera.lookAt(pivot.position);
}

addEventListener("pointerdown", (e)=>{
  if (e.target.closest('.rail') || e.target.closest('.arrows') || e.target.closest('.panel')) return;
  dragging = true; moved = false; lastX=e.clientX; lastY=e.clientY;
});
addEventListener("pointermove", (e)=>{
  if(!dragging) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  if (Math.abs(dx)+Math.abs(dy) > 2) moved = true;
  tTheta -= dx * CONFIG.ORBIT_SENS.theta;
  tPhi   -= dy * CONFIG.ORBIT_SENS.phi;
  tPhi = THREE.MathUtils.clamp(tPhi, CONFIG.PHI_MIN, CONFIG.PHI_MAX);
  lastX=e.clientX; lastY=e.clientY;
});
addEventListener("pointerup", (e)=>{
  if(!dragging){ return; }
  dragging = false;
  // if it was a click (not a drag), open the section overlay (clicking the cloud/title)
  if(!moved){
    openOverlay(section);
  }
});

/* Disable wheel scroll entirely (fully structured) */
addEventListener("wheel", e=>e.preventDefault(), { passive:false });

/* ================= Mouse interaction field (ambient reacts) ================= */
const raycaster = new THREE.Raycaster();
let mouseNDC = new THREE.Vector2();
let fieldPos = new THREE.Vector3(0,0,0); // point in space near pivot

addEventListener("pointermove", (e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
});

function updateMouseField(){
  // Intersect a plane through pivot, facing the camera
  const plane = new THREE.Plane();
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir);
  plane.setFromNormalAndCoplanarPoint(camDir, pivot.position);
  raycaster.setFromCamera(mouseNDC, camera);
  raycaster.ray.intersectPlane(plane, fieldPos);
}

/* ================= Navigation (arrows/menu/keys) ================= */
function setSection(to){
  section = to;
  document.querySelectorAll('.vnav button').forEach(b=>b.classList.toggle('active', b.dataset.key===keyFromIndex(section)));
  assignTargetsFor(section);
}
function keyFromIndex(i){ return ["start","work","about","contact"][i]; }
function next(){ setSection(Math.min(SECT.CONTACT, section+1)); }
function prev(){ setSection(Math.max(SECT.START, section-1)); }
document.getElementById("next").addEventListener("click", next);
document.getElementById("prev").addEventListener("click", prev);
document.querySelectorAll('.vnav button').forEach(btn=>{
  btn.addEventListener('click', ()=> setSection({start:0,work:1,about:2,contact:3}[btn.dataset.key]));
});
addEventListener("keydown", (e)=>{ if(e.key==="ArrowRight") next(); if(e.key==="ArrowLeft") prev(); });

/* ================= Overlay (click cloud/title to open) ================= */
const overlay = document.getElementById('overlay');
const ovTitle = document.getElementById('ov-title');
document.getElementById('close').addEventListener('click', ()=> overlay.classList.remove('show'));

function openOverlay(sec){
  const titles=["Samuel Goldman","Work","About","Contact"];
  ovTitle.textContent = titles[sec];
  overlay.classList.add('show');
}

/* ================= Resize safety: recompute targets so text never clips ================= */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  assignTargetsFor(section);
});

/* ================= Animate ================= */
const ambPosAttr=ambGeom.attributes.position;
const swarmPosAttr=swarmGeom.attributes.position;
const shapePosAttr=shapeGeom.attributes.position;
const clock=new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());
  nebulaUniforms.uTime.value += dt;

  updateCamera();
  updateMouseField();

  // Ambient: wander + mouse force + wrap
  const r2 = CONFIG.FIELD_RADIUS * CONFIG.FIELD_RADIUS;
  for(let i=0;i<ambCount;i++){
    const j=i*3;
    // mild wander + damping
    ambVel[j+0]=ambVel[j+0]*CONFIG.DAMPING + (Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambVel[j+1]=ambVel[j+1]*CONFIG.DAMPING + (Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambVel[j+2]=ambVel[j+2]*CONFIG.DAMPING + (Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;

    // mouse field (repulsive swirl)
    const dx=ambPos[j+0]- (fieldPos.x - pivot.position.x);
    const dy=ambPos[j+1]- (fieldPos.y - pivot.position.y);
    const dz=ambPos[j+2]- (fieldPos.z - pivot.position.z);
    const d2 = dx*dx+dy*dy+dz*dz;
    if (d2<r2){
      const f=(1 - d2/r2) * CONFIG.FIELD_FORCE;
      ambVel[j+0] += dx * f * dt * 30;
      ambVel[j+1] += dy * f * dt * 30;
      ambVel[j+2] += dz * f * dt * 30;
    }

    ambPos[j+0]+=ambVel[j+0];
    ambPos[j+1]+=ambVel[j+1];
    ambPos[j+2]+=ambVel[j+2];

    const B=CONFIG.BOX, Zmin=-350, Zmax=350;
    if(ambPos[j+0]<-B) ambPos[j+0]+=2*B; else if(ambPos[j+0]>B) ambPos[j+0]-=2*B;
    if(ambPos[j+1]<-B) ambPos[j+1]+=2*B; else if(ambPos[j+1]>B) ambPos[j+1]-=2*B;
    if(ambPos[j+2]<Zmin) ambPos[j+2]=Zmax; else if(ambPos[j+2]>Zmax) ambPos[j+2]=Zmin;
  }
  ambPosAttr.needsUpdate = true;

  // Swarm orbits title
  updateSwarm(); swarmPosAttr.needsUpdate = true;

  // Morph (single pull) then hold
  if(morphState.progress < 1){ morphState.progress = Math.min(1, morphState.progress + CONFIG.MORPH_RATE); }

  // Title particles: pull to targets, then settle
  for(let i=0;i<shapeCount;i++){
    const j=i*3, m=morphState.progress;
    vel[j+0] = vel[j+0]*CONFIG.DAMPING + (targets[j+0]-pos[j+0]) * CONFIG.ATTRACT * m;
    vel[j+1] = vel[j+1]*CONFIG.DAMPING + (targets[j+1]-pos[j+1]) * CONFIG.ATTRACT * m;
    vel[j+2] = vel[j+2]*CONFIG.DAMPING + (targets[j+2]-pos[j+2]) * CONFIG.ATTRACT * m;
    if(m===1){ vel[j+0]*=0.94; vel[j+1]*=0.94; vel[j+2]*=0.94; }
    pos[j+0]+=vel[j+0]; pos[j+1]+=vel[j+1]; pos[j+2]+=vel[j+2];
  }
  shapePosAttr.needsUpdate = true;

  renderer.render(scene,camera);
}
animate();

/* Build text once fonts are ready */
prepareText();
</script>
</body>
</html>
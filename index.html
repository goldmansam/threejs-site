<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Samuel Goldman — Particle Portfolio</title>
<style>
  html,body{height:100%;margin:0;background:#07080c;overflow:hidden}
  canvas{display:block}

  /* Left rail menu */
  .rail{
    position:fixed;inset:0 auto 0 0;width:210px;z-index:20;
    padding:18px 14px;display:grid;gap:10px;align-content:start;
    background:linear-gradient(180deg,rgba(10,12,18,.7),rgba(10,12,18,.35));
    border-right:1px solid rgba(255,255,255,.08);backdrop-filter:blur(8px);
    color:#e8eef8;font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif
  }
  .brand{font-weight:700;letter-spacing:.01em;opacity:.95}
  .vnav{display:grid;gap:8px;margin-top:6px}
  .vnav button{
    appearance:none;border:1px solid rgba(255,255,255,.14);
    background:rgba(20,22,28,.48);color:#e8eef8;padding:10px 12px;border-radius:999px;
    text-align:left;cursor:pointer;transition:all .16s ease
  }
  .vnav button:hover{border-color:rgba(255,255,255,.28);background:rgba(28,30,36,.58)}
  .vnav button.active{color:#9ff;border-color:rgba(160,240,255,.55)}

  /* Arrow controls (bottom-right) */
  .arrows{position:fixed;right:20px;bottom:20px;z-index:20;display:flex;gap:10px}
  .arrow{
    width:46px;height:46px;border-radius:999px;border:1px solid rgba(255,255,255,.2);
    background:radial-gradient(120% 120% at 30% 30%, rgba(255,255,255,.25), rgba(30,32,40,.5));
    box-shadow:0 0 18px rgba(160,240,255,.25), inset 0 0 18px rgba(160,240,255,.15);
    color:#e8eef8;display:grid;place-items:center;cursor:pointer;user-select:none
  }
  .arrow:hover{box-shadow:0 0 22px rgba(160,240,255,.35), inset 0 0 22px rgba(160,240,255,.2)}
  .arrow span{font-size:18px;transform:translateY(-1px)}

  /* Prompt */
  .overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:25;pointer-events:none}
  .prompt{
    color:#e8eef8;font:18px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:rgba(10,12,18,.6);border:1px solid rgba(255,255,255,.15);
    padding:14px 18px;border-radius:12px;backdrop-filter:blur(6px);opacity:.95
  }
  .prompt.hide{display:none}

  @media(max-width:920px){.rail{width:170px}}
</style>
</head>
<body>
  <!-- Left menu -->
  <aside class="rail">
    <div class="brand">Samuel Goldman</div>
    <div class="vnav">
      <button data-key="start"   class="active">Start</button>
      <button data-key="work">Work</button>
      <button data-key="about">About</button>
      <button data-key="contact">Contact</button>
    </div>
  </aside>

  <!-- Arrows -->
  <div class="arrows">
    <div class="arrow" id="prev"><span>◀</span></div>
    <div class="arrow" id="next"><span>▶</span></div>
  </div>

  <!-- Prompt -->
  <div class="overlay"><div id="prompt" class="prompt">Use the arrows or menu to explore</div></div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ================= Config ================= */
const CONFIG = {
  // Particles
  AMBIENT_COUNT: 7000,      // background cloud
  SHAPE_COUNT:   9000,      // used to form words
  BOX: 130,                 // ambient bounds (half-size)
  BASE_SPEED: 0.03,
  DAMPING: 0.985,

  // Camera
  CAMERA_FOV: 60,
  CAMERA_Z: 150,            // fixed camera distance (no scroll)
  LOOK_SENS: { yaw: 0.22, pitch: 0.14 }, // subtle mouse look

  // Words
  SECTIONS: ["Samuel Goldman", "Work", "About", "Contact"],
  CANVAS_W: 1800,           // raster width for sampling
  STEP: 4,                  // sampling step (lower = more points)
  THICKNESS: 3,             // +/-Z depth jitter
  OUTLINE_ONLY: true,       // edge points only for crisp glyphs

  // Morph (one pull per section)
  ATTRACT: 0.012,           // attraction to target
  MORPH_RATE: 0.018,        // 0->1 rate for each section

  // Dots
  DOT_SIZE: 0.62,
  DOT_OPACITY: 0.95
};

// UI state
const SECT = { START:0, WORK:1, ABOUT:2, CONTACT:3 };

/* ================= Scene ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x06070b, 0.006);

const camera = new THREE.PerspectiveCamera(CONFIG.CAMERA_FOV, innerWidth/innerHeight, 0.1, 4000);
camera.position.set(0, 0, CONFIG.CAMERA_Z);

const rig = new THREE.Object3D(); scene.add(rig); rig.add(camera);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setClearColor(0x07080c, 1);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x334455, 0.65));

/* ============ Nebula “tie-dye” background ============ */
const nebulaUniforms = { uTime:{value:0}, uIntensity:{value:0.85}, uHueShift:{value:0.0} };
const nebulaMat = new THREE.ShaderMaterial({
  side: THREE.BackSide, uniforms: nebulaUniforms,
  vertexShader: /*glsl*/`
    varying vec3 vPos;
    void main(){ vPos = normalize(position);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
  fragmentShader: /*glsl*/`
    precision highp float; varying vec3 vPos; uniform float uTime; uniform float uIntensity; uniform float uHueShift;
    float n(vec3 p){ return sin(p.x)*sin(p.y)*sin(p.z); }
    float fbm(vec3 p){ float f=0.0,a=0.5; for(int i=0;i<6;i++){ f+=a*n(p); p*=2.03; p+=vec3(.1,.27,-.19); a*=.55; } return f; }
    vec3 pal(float t){
      vec3 a=vec3(.35,.7,.9), b=vec3(.9,.35,.75), c=vec3(.85,.75,.3);
      float k1=.5+.5*sin(6.2831*(t+uHueShift)), k2=.5+.5*sin(6.2831*(t*1.3+.23+uHueShift));
      return mix(mix(a,b,k1), c, k2);
    }
    void main(){
      vec3 p = normalize(vPos)*2.0 + vec3(0.,0.,uTime*0.03);
      float d = fbm(p*2.0 + uTime*0.05);
      float m = smoothstep(-.6,.9,d);
      vec3 col = mix(vec3(.04,.05,.07), pal(m), uIntensity*(.35+.65*m));
      gl_FragColor = vec4(col, 1.0);
    }`
});
const nebula = new THREE.Mesh(new THREE.SphereGeometry(2000,64,64), nebulaMat);
rig.add(nebula); // follows camera so it never goes black

/* ============ Round dot texture ============ */
function makeDotTexture(size=64){
  const c=document.createElement("canvas"); c.width=c.height=size; const g=c.getContext("2d");
  const r=size/2, grad=g.createRadialGradient(r,r,0,r,r,r);
  grad.addColorStop(0,"rgba(255,255,255,1)"); grad.addColorStop(.7,"rgba(255,255,255,.9)"); grad.addColorStop(1,"rgba(255,255,255,0)");
  g.fillStyle=grad; g.beginPath(); g.arc(r,r,r,0,Math.PI*2); g.fill();
  const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=false; return tex;
}
const dotTex = makeDotTexture();

/* ============ Ambient particles (always-on) ============ */
const pal = [
  [0.30,0.85,0.90],[0.90,0.35,0.85],[0.85,0.75,0.30],
  [0.40,0.95,0.85],[0.95,0.40,0.70],[0.75,0.85,0.35]
];
const rnd=(a,b)=>a+Math.random()*(b-a);

const ambCount=CONFIG.AMBIENT_COUNT;
const ambPos=new Float32Array(ambCount*3), ambVel=new Float32Array(ambCount*3), ambCol=new Float32Array(ambCount*3);
for(let i=0;i<ambCount;i++){
  const i3=i*3;
  ambPos[i3+0]=rnd(-CONFIG.BOX,CONFIG.BOX);
  ambPos[i3+1]=rnd(-CONFIG.BOX,CONFIG.BOX);
  ambPos[i3+2]=rnd(-200, 220);
  ambVel[i3+0]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  ambVel[i3+1]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  ambVel[i3+2]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  const c=pal[(Math.random()*pal.length)|0]; ambCol[i3+0]=c[0]; ambCol[i3+1]=c[1]; ambCol[i3+2]=c[2];
}
const ambGeom=new THREE.BufferGeometry();
ambGeom.setAttribute("position", new THREE.BufferAttribute(ambPos,3));
ambGeom.setAttribute("color",    new THREE.BufferAttribute(ambCol,3));
const ambMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE*0.8,map:dotTex,alphaTest:0.02,vertexColors:true,transparent:true,opacity:0.75,depthWrite:false,blending:THREE.AdditiveBlending
});
const ambientPoints=new THREE.Points(ambGeom,ambMat); scene.add(ambientPoints);

/* ============ Word particles (form the titles) ============ */
const shapeCount=CONFIG.SHAPE_COUNT;
const pos=new Float32Array(shapeCount*3), vel=new Float32Array(shapeCount*3), col=new Float32Array(shapeCount*3);
for(let i=0;i<shapeCount;i++){
  const i3=i*3;
  pos[i3+0]=rnd(-CONFIG.BOX*0.5,CONFIG.BOX*0.5);
  pos[i3+1]=rnd(-CONFIG.BOX*0.5,CONFIG.BOX*0.5);
  pos[i3+2]=rnd(-20,20);
  vel[i3+0]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  vel[i3+1]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  vel[i3+2]=rnd(-CONFIG.BASE_SPEED,CONFIG.BASE_SPEED);
  const c=pal[(Math.random()*pal.length)|0]; col[i3+0]=c[0]; col[i3+1]=c[1]; col[i3+2]=c[2];
}
const shapeGeom=new THREE.BufferGeometry();
shapeGeom.setAttribute("position", new THREE.BufferAttribute(pos,3));
shapeGeom.setAttribute("color",    new THREE.BufferAttribute(col,3));
const shapeMat=new THREE.PointsMaterial({
  size:CONFIG.DOT_SIZE,map:dotTex,alphaTest:0.02,vertexColors:true,transparent:true,opacity:CONFIG.DOT_OPACITY,depthWrite:false,blending:THREE.AdditiveBlending
});
const shapePoints=new THREE.Points(shapeGeom,shapeMat); scene.add(shapePoints);

const targets=new Float32Array(shapeCount*3); // per-particle target
const morphState={progress:1};                // 0..1

/* ====== Text sampling → normalized points (never cut off) ====== */
function sampleTextNormalized(text){
  const W=CONFIG.CANVAS_W, H=Math.round(W*0.22);
  const cnv=document.createElement("canvas"); cnv.width=W; cnv.height=H;
  const ctx=cnv.getContext("2d"); ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#fff"; ctx.font=`bold ${Math.round(H*0.8)}px system-ui, Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(text, W/2, H/2);
  const img=ctx.getImageData(0,0,W,H).data;

  const pts=[]; const step=CONFIG.STEP;
  const aAt=(x,y)=>img[(y*W+x)*4+3];
  for(let y=step;y<H-step;y+=step){
    for(let x=step;x<W-step;x+=step){
      if(aAt(x,y)>128){
        if(!CONFIG.OUTLINE_ONLY){ pts.push([x,y]); }
        else {
          const edge=(aAt(x+step,y)<128)||(aAt(x-step,y)<128)||(aAt(x,y+step)<128)||(aAt(x,y-step)<128);
          if(edge) pts.push([x,y]);
        }
      }
    }
  }
  // normalize: use W so height keeps aspect; map to [-0.5..0.5] based on width
  return pts.map(([x,y])=>[(x-W/2)/W, (H/2-y)/W]); // z added later
}
// Build once
const NORM_POINTS = {
  0: sampleTextNormalized("Samuel Goldman"),
  1: sampleTextNormalized("Work"),
  2: sampleTextNormalized("About"),
  3: sampleTextNormalized("Contact")
};

// Safe world width (so words never clip), recomputed on resize
function safeWorldWidth(){
  const fovRad = THREE.MathUtils.degToRad(CONFIG.CAMERA_FOV);
  const visibleW = 2 * CONFIG.CAMERA_Z * Math.tan(fovRad/2) * (innerWidth/innerHeight);
  return visibleW * 0.78; // 78% of width as safe area
}

// Assign targets for a section (use ALL particles for a dense word)
function assignTargetsFor(sectionIndex){
  const pts = NORM_POINTS[sectionIndex];
  const safeW = safeWorldWidth();
  for(let i=0;i<shapeCount;i++){
    const t = pts[(Math.random()*pts.length)|0];
    const j=i*3;
    targets[j+0] = t[0] * safeW;
    targets[j+1] = t[1] * safeW;
    targets[j+2] = THREE.MathUtils.randFloatSpread(CONFIG.THICKNESS*2);
  }
  morphState.progress = 0; // start a fresh pull
}

/* ================= Navigation ================= */
let section = SECT.START; // start on "Samuel Goldman"
assignTargetsFor(section);

const order=[SECT.START, SECT.WORK, SECT.ABOUT, SECT.CONTACT];
function setSection(to){
  section = to;
  document.querySelectorAll('.vnav button').forEach(b=>b.classList.toggle('active', b.dataset.key===keyFromIndex(section)));
  assignTargetsFor(section);
}
function keyFromIndex(i){ return ["start","work","about","contact"][i]; }
function next(){ const idx = order.indexOf(section); setSection(order[Math.min(order.length-1, idx+1)]); }
function prev(){ const idx = order.indexOf(section); setSection(order[Math.max(0, idx-1)]); }

document.getElementById("next").addEventListener("click", next);
document.getElementById("prev").addEventListener("click", prev);
document.querySelectorAll('.vnav button').forEach(btn=>{
  btn.addEventListener('click', ()=> setSection({start:0,work:1,about:2,contact:3}[btn.dataset.key]));
});

// keyboard arrows
addEventListener("keydown", (e)=>{
  if(e.key==="ArrowRight") next();
  if(e.key==="ArrowLeft")  prev();
});

// Prevent scroll (we’re click/arrow only)
addEventListener("wheel", e=>e.preventDefault(), { passive:false });

/* ================= Interaction (subtle look) ================= */
let mouseX=0, mouseY=0, yaw=0, pitch=0, tyaw=0, tpitch=0;
addEventListener("pointermove", e=>{
  const nx=(e.clientX/innerWidth)*2-1, ny=(e.clientY/innerHeight)*2-1;
  mouseX=nx; mouseY=ny;
  tyaw   = nx * CONFIG.LOOK_SENS.yaw;
  tpitch = -ny * CONFIG.LOOK_SENS.pitch;
},{passive:true});

/* ================= Resize safety ================= */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  // Recompute targets for current section so text never clips on resize
  assignTargetsFor(section);
});

/* ================= Animate ================= */
const ambPosAttr=ambGeom.attributes.position;
const shapePosAttr=shapeGeom.attributes.position;
const clock=new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());
  nebulaUniforms.uTime.value += dt;

  // Rig look
  yaw += (tyaw - yaw) * 0.06;
  pitch += (tpitch - pitch) * 0.06;
  rig.rotation.set(pitch, yaw, 0);

  // Ambient cloud: gentle wander + wrap
  for(let i=0;i<ambCount;i++){
    const j=i*3;
    ambVel[j+0]=ambVel[j+0]*CONFIG.DAMPING + (Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambVel[j+1]=ambVel[j+1]*CONFIG.DAMPING + (Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambVel[j+2]=ambVel[j+2]*CONFIG.DAMPING + (Math.random()-0.5)*CONFIG.BASE_SPEED*0.02;
    ambPos[j+0]+=ambVel[j+0]; ambPos[j+1]+=ambVel[j+1]; ambPos[j+2]+=ambVel[j+2];
    const B=CONFIG.BOX;
    if(ambPos[j+0]<-B) ambPos[j+0]+=2*B; else if(ambPos[j+0]>B) ambPos[j+0]-=2*B;
    if(ambPos[j+1]<-B) ambPos[j+1]+=2*B; else if(ambPos[j+1]>B) ambPos[j+1]-=2*B;
    const Zmin=-220-120, Zmax=220+120; // deep range so it never feels empty
    if(ambPos[j+2]<Zmin) ambPos[j+2]=Zmax; else if(ambPos[j+2]>Zmax) ambPos[j+2]=Zmin;
  }
  ambPosAttr.needsUpdate = true;

  // Morph progress rises to 1 once per section (one clean pull)
  if(morphState.progress < 1){
    morphState.progress = Math.min(1, morphState.progress + CONFIG.MORPH_RATE);
  }

  // Word particles: attraction to targets scaled by morph (then hold)
  for(let i=0;i<shapeCount;i++){
    const j=i*3;
    // approach target
    const m = morphState.progress;
    vel[j+0] = vel[j+0]*CONFIG.DAMPING + (targets[j+0]-pos[j+0]) * CONFIG.ATTRACT * m;
    vel[j+1] = vel[j+1]*CONFIG.DAMPING + (targets[j+1]-pos[j+1]) * CONFIG.ATTRACT * m;
    vel[j+2] = vel[j+2]*CONFIG.DAMPING + (targets[j+2]-pos[j+2]) * CONFIG.ATTRACT * m;

    // when fully formed, stop wandering (keep rock-solid)
    if(m === 1){
      vel[j+0] *= 0.95; vel[j+1] *= 0.95; vel[j+2] *= 0.95;
    } else {
      // tiny sparkle during pull
      vel[j+0] += (Math.random()-0.5)*CONFIG.BASE_SPEED*0.01;
      vel[j+1] += (Math.random()-0.5)*CONFIG.BASE_SPEED*0.01;
      vel[j+2] += (Math.random()-0.5)*CONFIG.BASE_SPEED*0.01;
    }

    pos[j+0]+=vel[j+0]; pos[j+1]+=vel[j+1]; pos[j+2]+=vel[j+2];
  }
  shapePosAttr.needsUpdate = true;

  renderer.render(scene,camera);
}
animate();

// Hide prompt after a second
setTimeout(()=>document.getElementById("prompt")?.classList.add("hide"), 1600);
</script>
</body>
</html>